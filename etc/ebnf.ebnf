    /* An EBNF grammar for EBNF */
    [1] ebnf        ::= ( (rule (rule | declaration)*)
                        | (id_rule (id_rule | declaration)*))?

    [2] declaration ::= '@terminals' | pass

    # Split the rule into those beginning with an identifier, and those not,
    # creating two different branches for parsing.
    # This prevends an issue where ID can be mistaken for RANGE
    [3] rule        ::= LHS expression

    [3i] id_rule    ::= ID LHS expression

    [4] expression  ::= alt

    [5] alt         ::= seq ('|' seq)*

    [6] seq         ::= diff+

    [7] diff        ::= postfix ('-' postfix)?

    [8] postfix     ::= primary POSTFIX?

    [9] primary     ::= HEX
                    |   SYMBOL
                    |   O_RANGE
                    |   RANGE
                    |   STRING1
                    |   STRING2
                    |   '(' expression ')'

    [10] pass       ::= '@pass' expression

    @terminals

    [11] ID        ::= '[' SYMBOL ']'

    [12] LHS        ::= SYMBOL ' '* '::='

    [13] SYMBOL     ::= ([a-z] | [A-Z] | [0-9] | '_' | '.')+

    [14] HEX        ::= '#x' ([a-f] | [A-F] | [0-9])+

    [15] RANGE      ::= '[' ((R_CHAR '-' R_CHAR) | (HEX '-' HEX) | R_CHAR | HEX)+ '-'? ']'

    [16] O_RANGE    ::= '[^' ((R_CHAR '-' R_CHAR) | (HEX '-' HEX) | R_CHAR | HEX)+ '-'? ']'

    # Strings are unescaped Unicode, excepting control characters and hash (#)
    [17] STRING1    ::= '"' (CHAR - '"')* '"'

    [18] STRING2    ::= "'" (CHAR - "'")* "'"

    [19] CHAR       ::= [#x9#xA#xD] | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

    [20] R_CHAR     ::= CHAR - (']' | '-' | HEX)

    [21] POSTFIX    ::= [?*+]

    # Ignore all whitespace and comments between non-terminals
    [22] PASS       ::= [#x9#xA#xD#x20]
                      | ( ('#' - '#x') | '//' ) [^#xA#xD]*
                      | '/*' (( '*' [^/] )? | [^*] )* '*/'
                      | '(*' (( '*' [^)] )? | [^*] )* '*)'

    @pass           PASS

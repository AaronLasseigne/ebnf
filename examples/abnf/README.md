# IETF ABNF Parser example

This example implements an [ABNF][] parser which parses compatible grammars into [S-Expressions][S-Expression]. This allows the resulting [S-Expressions][] to drive a PEG Parser to parser documents defined using [ABNF][].

## Parsing the Grammar

    require 'ebnf'

    abnf = ABNFParser.new(File.open("abnf.abnf"))

Output rules and terminals as [S-Expression][S-Expression]:

    puts abnf.to_sxp

This generates a [S-Expression][] form of the grammar suitable for use by {EBNF}.

    (
     (rule rulelist (plus (alt rule (seq (star c-wsp) c-nl))))
     (rule rule (seq rulename defined-as elements c-nl))
     (rule rulename (seq ALPHA (star (alt ALPHA DIGIT "-"))))
     (rule defined-as (seq (star c-wsp) (alt "=" "=/") (star c-wsp)))
     (rule elements (seq alternation (star c-wsp)))
     (rule c-wsp (alt WSP (seq c-nl WSP)))
     (rule c-nl (alt comment CRLF))
     (rule comment (seq ";" (star (alt WSP VCHAR)) CRLF))
     (rule alternation
      (seq concatenation (star (seq (star c-wsp) "/" (star c-wsp) concatenation))))
     (rule concatenation (seq repetition (star (seq (plus c-wsp) repetition))))
     (rule repetition (seq (opt repeat) element))
     (rule repeat (alt (seq (star DIGIT) "*" (star DIGIT)) (plus DIGIT)))
     (rule element (alt rulename group option char-val num-val prose-val))
     (rule group (seq "(" (star c-wsp) alternation (star c-wsp) ")"))
     (rule option (seq "[" (star c-wsp) alternation (star c-wsp) "]"))
     (rule char-val (alt case-insensitive-string case-sensitive-string))
     (rule case-insensitive-string (seq (opt "%i") quoted-string))
     (rule case-sensitive-string (seq "%s" quoted-string))
     (rule quoted-string
      (seq DQUOTE (star (alt (range "#x20-#x21") (range "#x23-#x7e"))) DQUOTE))
     (rule num-val (seq "%" (alt bin-val dec-val hex-val)))
     (rule bin-val (seq "b" (plus BIT) (opt (alt (plus (seq "." (plus BIT))) (seq "-" (plus BIT))))))
     (rule dec-val
      (seq "d" (plus DIGIT) (opt (alt (plus (seq "." (plus DIGIT))) (seq "-" (plus DIGIT))))))
     (rule hex-val
      (seq "x" (plus HEXDIG) (opt (alt (plus (seq "." (plus HEXDIG))) (seq "-" (plus HEXDIG))))))
     (rule prose-val (seq "<" (star (alt (range "#x20-#x3d") (range "#x3f-#x7e"))) ">"))
     (terminal ALPHA (alt (range "#x41-#x5a") (range "#x61-#x7a")))
     (terminal BIT (alt "0" "1"))
     (terminal CHAR (range "#x1-#x7f"))
     (terminal CR (hex "#x0D"))
     (terminal CRLF (seq (opt CR) LF))
     (terminal CTL (alt (range "#x0-#x1f") (hex "#x7F")))
     (terminal DIGIT (range "#x30-#x39"))
     (terminal DQUOTE (hex "#x22"))
     (terminal HEXDIG (alt DIGIT "A" "B" "C" "D" "E" "F"))
     (terminal HTAB (hex "#x09"))
     (terminal LF (hex "#x0A"))
     (terminal LWSP (star (alt WSP (seq CRLF WSP))))
     (terminal OCTET (range "#x0-#xff"))
     (terminal SP (hex "#x20"))
     (terminal VCHAR (range "#x21-#x7e"))
     (terminal WSP (alt SP HTAB)))

This can then be used as input to {EBNF.parse} to transform ABNF to PEG for parsing examples of the grammar using {EBNF::PEG::Parser}.

    ebnf --input-format sxp --peg abnf.sxp -o abnf.peg.sxp

Note, however, that ABNF doesn't distinguish between terminal rules and non-terminal rules, so all rules are parsed as non-terminal rules with strings the only terminals.

When parsing files with this grammar, rules that are all capitalized _will_ be treated as terminal productions, although this is an proprietary interpretation of the specification.

## Example Walkthrough

This example uses the [EBNF][] grammar from {file:abnf.ebnf} to generate {file:meta}, which includes the resulting `RULES` table, used by {file:parser} to implement a parser for the grammar. It also uses {file:abnf-core.ebnf} to create {file:core} which contains the core ABNF terminals useable by ABNF grammars without specifically defining them.

The first step is defining regular expressions for terminals used within the grammar. Note that the parser can operate without terminal definitions, but this can greatly improve parser performance.

The {file:parser} is implemented using the {ABNFParser} class, which includes {EBNF::PEG::Parser}.

### Parser basics
The parser operates directly using the rules from the abstract syntax tree generated by turning the original [EBNF][] grammar using {EBNF::PEG#make_peg}. Tokens are derived from terminal rules defined in the grammar or contained inline through non-terminal rule definitions. Terminals are either strings, which must be matched exactly, or symbols, which identify a regular expression used to match the terminal and yield a token. The association between terminal symbols and their regular expressions along with processing rules to invoke when they are identified are described in [Terminal definitions](#Terminal_definitions).

The parser starts with the specified rule, `rulelist` in this case, and executes that rule, which is expected to completely parse the input file potentially leaving some whitespace.

Non-terminal rules have an expression using one of the following:

`seq`
: A sequence of rules or terminals. If any (other than `opt` or `star`) to not parse, the rule is terminated as unmatched.
`opt`
: An optional rule or terminal. It either results in the matching rule or returns `nil`.
`alt`
: A list of alternative rules, which are attempted in order. It terminates with the first matching rule, or is terminated as unmatched, if no such rule is found.
`plus`
: A sequence of one or more of the matching rule. If there is no such rule, it is terminated as unmatched; otherwise, the result is an array containing all matched input.
`rept m n`
: A sequence of at lest `m` and at most `n` of the matching rule. It will always return an array.
`star`
: A sequence of zero or more of the matching rule. It will always return an array.

The starting rule is of the form `(rule rulelist (plus (alt rule (seq (star c_wsp) c_nl))))` which will attempt to parse the aliteration repeatedly until the end of input.

If a rule matches, it enters a _production_, which may invoke a _start production before matching is attempted, and will call any _production_ either if matched, or unmatched. In the case of this parser, the _start production_ is used to declare the `as_hash` option on sequences, which causes the matched values to be represented using a Hash, rather than an array of hashes for each element of the sequence, which is the default behavior. The _production_ may choose to evaluate the returned abstract syntax tree to simplify the result, or create some semantic representation of that value.

Due to the nature of [PEG][] parsers, the same rule may be attempted at the same input location many times; this is optimized by use of a [Packrat][] memoizing cache, which remembers the result of a previous successful evaluation and short-circuits further execution.

Processing continues by continuing to look for productions sequence and pushing those productions onto the stack. When a production is complete, any associated _production handler_ is invoked, after popping off the top of the `prod_data` stack. The just removed hash is passed as `current` to the _production handler_. This is typically where the work of the parser happens. See [Production definitions](#Production_definitions) for more information.

### Terminal definitions
The {file:parser} uses a DSL to specify `terminals` and `productions` associated with rules in the grammar. Each `terminal` specifies the rule name, associated regular expression, and a block which is invoked when the parser recognizes the terminal:

    terminal(:quoted_string, /"[\x20-\x21\x23-\x7E]*"/) do |value|
      value[1..-2]
    end

In this terminal definition, the `quoted_string` is treated as a terminal and is recognized using the `/"[\x20-\x21\x23-\x7E]*"/` regular expression. When found, the value of the string is returned, minus the beginning and ending double-quote characters, for use by productions which include it.

### Production definitions
Looking at the grammar itself, we can see that the first declaration is

    rulelist     ::=  ( rule | (c_wsp* c_nl) )+

which corresponds to the original ABNF rule

    rulelist       =  1*( rule / (*c-wsp c-nl) )

In some cases, [ABNF][] can represent expressions not directly available in [EBNF][], such as the following portion from {file:examples/postal-address.abnf}:

    house-num        = 1*8(DIGIT / ALPHA)

In [EBNF][], this would be represented more explicitly:

    house_num      ::= (DIGIT / ALPHA)
                       ((DIGIT / ALPHA)
                        ((DIGIT / ALPHA)
                         ((DIGIT / ALPHA)
                          {(DIGIT / ALPHA)
                           (DIGIT / ALPHA)
                            ((DIGIT / ALPHA)
                             (DIGIT / ALPHA)?)?}?)?)?)?

However, there is a `rept` [S-Expression][] that represents the min/max repeating capability more directly.

    (rule house_num (rept 1 8 (alt DIGIT ALPHA)))

[EBNF]:         https://www.w3.org/TR/REC-xml/#sec-notation
[Packrat]:      https://pdos.csail.mit.edu/~baford/packrat/thesis/
[ABNF]:         https://www.rfc-editor.org/rfc/rfc5234
[S-expression]: https://en.wikipedia.org/wiki/S-expression
